<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />

    <title>Towards a Quatum Software Modeling Language</title>
    <link rel="shortcut icon" href="./favicon.ico"/>
    <link rel="stylesheet" href="./dist/reveal.css" />
    <link rel="stylesheet" href="./dist/theme/white.css" id="theme" />
    <link rel="stylesheet" href="./css/highlight/zenburn.css" />

  </head>
  <body>
    <div class="reveal">
      <div class="slides"><section  data-markdown><script type="text/template">
<style type="text/css">
p { text-align: left; font-size: 1em;}
</style>

**Title**

Towards a Quantum Software Modeling Language

**Authors**

Carlos A. Pérez-Delgado, Hector G. Perez-Gonzalez

</script></section><section  data-markdown><script type="text/template">

### Abstract

- The author sets down the principles behind a modeling language for QC.
- A minimal set of extensions to UML (Unified Modeling Language)
- A small set of examples that showcase the effectiveness of the extension set.

</script></section><section  data-markdown><script type="text/template">

### 1. Introduction

- Quantum computation has, until today, been studied almost exclusively **‘in the small.’**
- So we need a general understanding of QC/Quantum programming **'in the large'**.
- The author aims to set the foundations of a general framework for quantum programs **based on UML**.
- Introducing a minimum set of extensions based on UML.

</script></section><section  data-markdown><script type="text/template">

### 2. Q-UML

The **guiding principles** behind any quantum software modeling language.

</script></section><section  data-markdown><script type="text/template">

(1) Quantum Classes

</script></section><section  data-markdown><script type="text/template">

(2) Quantum Elements

- Quantum Variables
  - classical:  integer, string...
  - quantum: qubit, qubit array...
  
- Quantum Operations

  For each operation, both the input and output should be clearly labelled as either classical or quantum.

</script></section><section  data-markdown><script type="text/template">

(3) Quantum Supremacy

- A Module that has at least one quantum element is to be considered a quantum software module.
- Quantum and classical modules should be clearly labelled.

</script></section><section  data-markdown><script type="text/template">

(4) Quantum Aggregation

- Any module that is composed of one or more quantum modules will itself be considered a quantum module.

</script></section><section  data-markdown><script type="text/template">

(5) Quantum Communication

- Quantum and classical modules can communicate with each other as long as their interfaces are compatible.

</script></section><section  data-markdown><script type="text/template">

In the following Section 2.1 and 2.2, these principles will be put into practice.

</script></section><section  data-markdown><script type="text/template">

#### 2.1 Class Diagram Extensions

![image-20210429213846722](https://raw.githubusercontent.com/yukariio/img/master/img-image-20210429213846722.png)

</script></section><section  data-markdown><script type="text/template">

- For attributes

  The name will be bold if it is represented using quantum information.

- For methods

  If any of the inputs are quantum, these are bold.

  If the output or datatype of the method is quantum, then the datatype should also be bold.

</script></section><section  data-markdown><script type="text/template">

Relationships between classes:

- double-lines for quantum relationship

</script></section><section  data-markdown><script type="text/template">

#### 2.2 Sequence Diagram Extensions

This paper extends the existing language in order to
allow us to differentiate between classical and quantum messages.

we make use of 

- **bold** text to markup **quantum modules**.
- **double lines** to portray **quantum messages**.

</script></section><section  data-markdown><script type="text/template">

![image-20210429214806897](https://raw.githubusercontent.com/yukariio/img/master/img-image-20210429214806897.png)

</script></section><section  data-markdown><script type="text/template">

#### 2.3 Discussion

- The necessity

  Quantum information behaves differently from classical information. We must differentiate between classical and quantum information.

</script></section><section  data-markdown><script type="text/template">

- The sufficiency

  All quantum computation is simulable using classical computation albeit with an efficiency loss.

  Other than their use of quantum information and
  algorithms, quantum computers are indistinct from classical ones.

  The only information element that needs to be considered when developing quantum
  software is when quantum (rather than classical) information is being used.

</script></section><section  data-markdown><script type="text/template">

Last information element not yet discussed.

- algorithm efficiency

  The reason why we use quantum computation is mostly due to the efficiency.

  UML itself does not inherently have language elements for algorithm efficiency.

  - It does, however,have several extensions used and proposed for this purpose.</script></section></div>
    </div>

    <script src="./dist/reveal.js"></script>

    <script src="./plugin/markdown/markdown.js"></script>
    <script src="./plugin/highlight/highlight.js"></script>
    <script src="./plugin/zoom/zoom.js"></script>
    <script src="./plugin/notes/notes.js"></script>
    <script src="./plugin/math/math.js"></script>
    <script>
      function extend() {
        var target = {};
        for (var i = 0; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (source.hasOwnProperty(key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }

      // default options to init reveal.js
      var defaultOptions = {
        controls: true,
        progress: true,
        history: true,
        center: true,
        transition: 'default', // none/fade/slide/convex/concave/zoom
        plugins: [
          RevealMarkdown,
          RevealHighlight,
          RevealZoom,
          RevealNotes,
          RevealMath
        ]
      };

      // options from URL query string
      var queryOptions = Reveal().getQueryHash() || {};

      var options = extend(defaultOptions, {"transition":"slide","slideNumber":"c/t","showSlideNumber":"all"}, queryOptions);
    </script>


    <script>
      Reveal.initialize(options);
    </script>
  </body>
</html>
